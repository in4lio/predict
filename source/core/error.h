
/*  error.h was generated by yup.py (yupp) 0.9b2
    out of error.yu-h 
 *//**
 *  \file  error.h (error.yu-h)
 *  \brief  Error messages.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

#define LOGGING
#define LINK_CONSOLE

#define LINK_UT

#define LINK_UT_UT
#define LINK_UT_CORO
#define LINK_UT_DATA

#ifndef ERROR_H
#define ERROR_H

#ifdef  ERROR_IMPLEMENT
#define ERROR_EXT
#define ERROR_EXT_INIT( dec, init ) \
	dec = init
#define ERROR_INL extern inline
#else
#define ERROR_EXT extern
#define ERROR_EXT_INIT( dec, init ) \
	extern dec
#define ERROR_INL inline
#endif

#ifndef COMMA
#define COMMA   ,
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 *  \defgroup error Error messages
 *  \ingroup core
 *
 *	Structure of <b>error-dict.yu</b> file:
 *
 *  <b>DATA_ERROR</b> - Dictionary of errors.
 *  \param DATA_ERROR Identifier of error.
 *  \param ERROR_BIT Bit in pool of errors (var_error).
 *  \param ERROR_FORMAT Message format.
 *  \param ERROR_REPEAT Flag of repeated error logging.
 *  \{
 */

/**
 *  \brief Output error message and set flag in pool of errors.
 *  \param err Identifier of error.
 *  \param ... Message arguments.
 *  \hideinitializer
 */
#define ERROR( err, ... ) do { \
	do { \
		data_set_word( var_error, SET_VALUE( data_get_word( var_error ), BIT( err_bit_##err ) )); \
	} while ( 0 ); \
	LOG_ERROR( err, ## __VA_ARGS__ ); \
	__echo_error( error_format[ error_##err ], err_bit_##err, ## __VA_ARGS__ ); \
} while ( 0 )

/**
 *  \brief Clear flag in pool of errors.
 *  \param err Identifier of error.
 *  \hideinitializer
 */
#define ERROR_CLEAR( err ) do { \
	do { \
		data_set_word( var_error, CLEAR_VALUE( data_get_word( var_error ), BIT( err_bit_##err ) )); \
	} while ( 0 ); \
} while ( 0 )

/**
 *  \brief Clear all error flags.
 *  \hideinitializer
 */
#define ERROR_CLEAR_ALL() do { \
	do { \
		data_set_word( var_error, 0 ); \
	} while ( 0 ); \
} while ( 0 )

/**
 *  \brief Verify error flag is cleared.
 *  \param err Identifier of error.
 *  \param op Operation if verification failed.
 *  \hideinitializer
 */
#define assert_unerring( err, op ) do { \
	bool bit = ( BIT( err_bit_##err ) & data_get_word( var_error )); \
	if ( bit ) { \
		ut_fault( "expected unerring", __FILE__,  __FUNCTION__, __LINE__ ); \
		op; \
	} \
} while ( 0 )

enum {
	error__TEST_COUNT,
	error_ut,
	error_heap,
	error_file_open,
	error_dir_open,
	error_file_is_empty,
	error_file_read,

};

enum {
	err_bit__TEST_COUNT = 0,
	err_bit_ut = 0,
	err_bit_heap = 0,
	err_bit_file_open = 4,
	err_bit_dir_open = 4,
	err_bit_file_is_empty = 4,
	err_bit_file_read = 4,

};

/**
 *  \brief Error messages formats.
 */
ERROR_EXT const char *const error_format[];

/** \} */

#ifdef __cplusplus
}
#endif

#endif

