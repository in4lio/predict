
/*  ut_2.c was generated by yup.py (yupp) 1.0b4
    out of ut_2.yu-c 
 *//**
 *  \file  ut_2.c (ut_2.yu-c)
 *  \brief  Unit testing of 2nd stage.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

#define LOGGING
#define LINK_CONSOLE

#define LINK_UT

#define LINK_UT_UT
#define LINK_UT_CORO
#define LINK_UT_DATA

#include "include.h"

/**
 *  \addtogroup ut
 *  \{
 */

/** ut_coro test coroutine alive flag. */
int ut_coro_alive;
/** ut_coro test coroutine local context. */
static co_t co_ut_coro;
/** ut_coro test coroutine. */
extern int coro_ut_coro( co_t *co_p );
/** Initialize ut_coro test coroutine. */
extern int ut_coro_init( void );
/** Uninitialize ut_coro coroutine. */
extern void ut_coro_uninit( void );
/** ut_data test coroutine alive flag. */
int ut_data_alive;
/** ut_data test coroutine local context. */
static co_t co_ut_data;
/** ut_data test coroutine. */
extern int coro_ut_data( co_t *co_p );
/** Initialize ut_data test coroutine. */
extern int ut_data_init( void );
/** Uninitialize ut_data coroutine. */
extern void ut_data_uninit( void );

int ut_2_init( void )
{
	co_ut_coro = NULL;
	ut_coro_alive = ut_coro_init();
	co_ut_data = NULL;
	ut_data_alive = ut_data_init();

	return ( CO_READY ); /* CO_SKIP */
}

void ut_2_uninit( void )
{
	ut_coro_uninit();
	ut_data_uninit();

}

/**
 *  \brief Schedule of test coroutines.
 *  \return true if testing is not complete.
 */
static int ut_2_schedule( void )
{
	if (( ut_coro_alive ) < CO_END ) ut_coro_alive = coro_ut_coro( &co_ut_coro );
	if (( ut_data_alive ) < CO_END ) ut_data_alive = coro_ut_data( &co_ut_data );

	return ( 0
	|| (( ut_coro_alive ) < CO_END )
	|| (( ut_data_alive ) < CO_END )

	);
}

/**
 *  \brief Coroutine of unit testing of 2nd stage.
 */
int coro_ut_2( co_t *co_p )
{
	static struct timeval __t;
	if ( *co_p ) goto **co_p;
	/* begin */
	ut_stage_2_start( 2 );  /* Start unit testing of 2nd stage */
	do {
		/* yield */
		*co_p = &&L__0;
	
		return CO_YIELD;

		L__0:;
	} while ( 0 );

	__t = clock_t_set( 1 * TICK_PER_SEC );
	do {
		/* wait */
		*co_p = &&L__1;

		L__1:
		if (!( clock_time_after( __t ))) { /* cond */
		
			return CO_WAIT;
		}
	} while ( 0 );  /* Pause before performing tests */
	/* Test coroutines call loop */
	do {
		/* wait */
		*co_p = &&L__2;

		L__2:
		if (!( !ut_stage_2( ut_2_schedule ))) { /* cond */
		
			return CO_WAIT;
		}
	} while ( 0 );
	/* end */
	*co_p = &&L__END_ut_2;

	L__END_ut_2:
	
	return CO_END;
}

void ut_2_restart( void )
{
	if ( ut_2_alive == CO_END ) {
		co_ut_2 = NULL;
		ut_2_alive = ut_2_init();
	}
}

/** \} */
