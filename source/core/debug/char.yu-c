($!                _ _     _
     ___ ___ ___ _| |_|___| |_
    |   |  _   _|   | |  _   _|
    |  _|_| |___ ___|_|___  |
    |_|                   |_)

($import "core.yu")
($TITLE,,Debug interface.)

($import stdlib)
($import h)
($import coroutine)
($import "config.yu")

($implement-named)

#include "include.h"

/** \mainpage <CENTER><BR>predict - an embedded application framework</CENTER>

<CENTER><TT><BR>
                 _ _     _     <BR>
   ___ ___ ___ _| |_|___| |_   <BR>
  |   |  _   _|   | |  _   _|  <BR>
  |  _|_| |___ ___|_|___  |    <BR>
  |_|                   |_|    <BR><BR><BR><BR>
</TT></CENTER>
 */

($skip-if-not LINK_CONSOLE)

/**
 *  \addtogroup char
 *  \{
 */

/**
 *  \brief Debug interface title message.
 *  \hideinitializer
 */
static const char * const TITLE = __CRLF__
#ifdef __CONSOLE_TITLE__
	__CONSOLE_TITLE__;
#else
	"               _ _     _   " __CRLF__
	" ___ ___ ___ _| |_|___| |_ " __CRLF__
	"|   |  _   _|   | |  _   _|" __CRLF__
	"|  _|_| |___ ___|_|___  |  " __CRLF__
	"|_|                   |_|  " __CRLF__;
#endif

($import "app.yu")

/**
 *  \brief Program version format.
 *  \hideinitializer
 */
const char * const VERSION_STRING =
	__CRLF__ ($q ($PROGRAM)) " " ($q ($VERSION)) " (" ($q ($FRAMEWORK_VERSION)) ")"
	__CRLF__ "Compiled with " ($q ($COMPILER)) " " __VERSION__;

/**
 *  \brief Input buffer.
 */
static char rx_buf[ RX_SIZE ];
static uint32_t rx_pos;
static bool is_msg;

#define FINE_BACKSPACE  "\x08\x20\x08"  /**< Sequence for delete last input char. \hideinitializer */
#define CLEAR_CMD       "                    \r" CONSOLE_PROMPT /**< Clear command line. \hideinitializer */

static const char const USED_CHAR_LIST[] = "0123456789_abcdefghijklmnopqrstuvwxyz";

// WIN32 /////////////////////////////////////////
#if defined( __WIN32__ )
#include <conio.h>

#define CHAR_BACKSPACE  '\x08'
#define CHAR_UP         '\x48'
#define CHAR_DOWN       '\x50'
#define CHAR_RIGHT      '\x4D'
#define CHAR_LEFT       '\x4B'

static void getch_init( void )
{
}

static void getch_uninit( void )
{
}

static __inline int getch_1( void )
{
	static struct timeval t = { 0, 0 };

	if ( clock_time_before( t )) return EOF;
	t = clock_t_set( 100 );

	/* Unfortunately, this version of kbhit() has long delay. */
	return ( kbhit() ? _getch() : EOF );
}

static __inline bool getch_esc( int chr )
{
	return (( chr == 0 ) || ( chr == 0xE0 ));
}

static __inline void detect_console_resolution( void )
{
}

// MSDOS /////////////////////////////////////////
#elif defined( __MSDOS__ )
#include <conio.h>

#define CHAR_BACKSPACE  '\x08'
#define CHAR_UP         '\x48'
#define CHAR_DOWN       '\x50'
#define CHAR_RIGHT      '\x4D'
#define CHAR_LEFT       '\x4B'

static void getch_init( void )
{
}

static void getch_uninit( void )
{
}

static __inline int getch_1( void )
{
	return ( kbhit() ? getch() : EOF );
}

static __inline bool getch_esc( int chr )
{
	return ( chr == 0 );
}

static __inline void detect_console_resolution( void )
{
}

// UNIX //////////////////////////////////////////
#else
#include <termios.h>

#define CHAR_BACKSPACE  '\x7F'
#define CHAR_UP         '\x41'
#define CHAR_DOWN       '\x42'
#define CHAR_RIGHT      '\x43'
#define CHAR_LEFT       '\x44'

static struct termios getch_o_attr;

static void getch_init( void )
{
	struct termios n_attr;

	/* Set terminal to raw mode */
	tcgetattr( fileno( stdin ), &getch_o_attr );
	memcpy( &n_attr, &getch_o_attr, sizeof( struct termios ));
	n_attr.c_lflag &= ~( ECHO | ICANON );
	n_attr.c_cc[ VTIME ] = 0;
	n_attr.c_cc[ VMIN  ] = 0;
	tcsetattr( fileno( stdin ), TCSANOW, &n_attr );
}

static void getch_uninit( void )
{
	/* Restore original terminal attributes */
	tcsetattr( fileno( stdin ), TCSANOW, &getch_o_attr );
}

static int getch( void )
{
	/* Read character from STDIN stream without blocking. Returns EOF (-1) if no character is available. */
	return fgetc( stdin );
}

static __inline int getch_1( void )
{
	return getch();
}

static __inline bool getch_esc( int chr )
{
	return (( chr == 0x1B ) && ( getch() == 0x5B ));
}

#include <sys/ioctl.h>

static __inline void detect_console_resolution( void )
{
	struct winsize w;
	ioctl( STDOUT_FILENO, TIOCGWINSZ, &w );
	console_row_count = w.ws_row;
	console_col_count = w.ws_col;
}
//////////////////////////////////////////////////
#endif

/**
 *  \brief Print greeting and initialize debug interface.
 */
int receive_char_init( void )
{
	printf( TITLE );
	print_version();
	printf( __CRLF__ );

	rx_pos = 0;
	is_msg = false;

	char_echo = 1;
	getch_init();
	detect_console_resolution();

	return ( CO_READY ); /* CO_SKIP */
}

void receive_char_uninit( void )
{
	getch_uninit();
}

/**
 *  \brief Coroutine of message receiving on debug interface.
 */
($coro-define receive_char ]
	for ( ; ; ) {
		/* Wait character */
		($coro-wait,,( chr = getch_1()) != EOF );

		if ( getch_esc( chr )) {
			chr = getch();

			if ( console_command_waited()  /* Console is waiting for command, no cyclic command, */
			&& ( rx_pos == 0 )) {          /* no one input character */
				/* Choose console command from list */
				printf( CLEAR_CMD );
				switch ( chr ) {

				case CHAR_UP:
					console_index = ( console_index > 1 ) ? console_index - 1 : CONSOLE_COMMAND_COUNT - 1;
					goto up_or_down_l;

				case CHAR_DOWN:
					console_index = ( console_index < CONSOLE_COMMAND_COUNT - 1 ) ? console_index + 1 : 1;

				up_or_down_l:
					/* Print command */
					printf( "%s\r" CONSOLE_PROMPT_LIST, console_command[ console_index ]);
					break;

				default:
					console_index = 0;
				}
			} else {
				/* Input message using only UP, DOWN and RIGHT arrows */
				switch ( chr ) {

				case CHAR_UP:    /* increase last entered char */
				case CHAR_DOWN:  /* decrease */
					if ( rx_pos == 0 ) break;

					char *p = strchr( USED_CHAR_LIST, rx_buf[ rx_pos - 1 ]);
					if ( p ) {
						if ( chr == CHAR_UP ) {
							chr = ( p[ 1 ]) ? p[ 1 ] : USED_CHAR_LIST[ 0 ];
						} else {
							chr = ( p == USED_CHAR_LIST ) ? USED_CHAR_LIST[ sizeof( USED_CHAR_LIST ) - 2 ] : *( p - 1 );
						}
					} else {
						chr = '0';
					}
					rx_buf[ rx_pos - 1 ] = chr;
					if ( char_echo ) {
						printf( "\x08%c", chr );
						fflush( stdout );
					}
					break;

				case CHAR_RIGHT: /* enter 0 */
					if ( rx_pos == RX_SIZE - 1 ) break;

					chr = '0';
					rx_buf[ rx_pos++ ] = chr;
					if ( char_echo ) {
						printf( "%c", chr );
						fflush( stdout );
					}
					break;
				}
			}
		} else {
			if ( console_index && ( chr != CHAR_ENTER )) {
				/* Reset command choice */
				console_index = 0;
				printf( CLEAR_CMD );
			}
			/* Handle character */
			switch ( chr ) {

			case CHAR_SPACE ... LAST_CHAR:
				rx_buf[ rx_pos++ ] = chr;
				if ( char_echo ) {
					printf( "%c", chr );
					fflush( stdout );
				}
				if ( rx_pos < RX_SIZE - 1 ) break;
				/* fallthrough */

			case CHAR_ENTER:
				is_msg = true;
				break;

			case CHAR_BACKSPACE:
				if ( rx_pos ) {
					--rx_pos;
					if ( char_echo ) printf( FINE_BACKSPACE );
				}
				break;
			}
		}
		($coro-yield);

		/* Prepare message */
		if ( is_msg ) {
			rx_buf[ rx_pos ] = 0;
			rx_pos = 0;
			char_received = rx_buf;
			is_msg = false;

			/* Wait message is handled */
			($coro-wait,, char_received == NULL );
		}
	}
[ \enter ]
	static int chr;
[ )

void char_clear_input( void )
{
	rx_pos = 0;
}

void printhr( byte *data, uint32_t len, uint32_t cols )
{
	uint32_t i;

	if ( cols == 0 ) cols = 16;

	for ( i = 0; i < len; i++ ) {
		if (( i % cols ) == 0 ) printf( __CRLF__ );
		printf( "%02X ", data[ i ]);
	}
}

void printh( byte *data, uint32_t len )
{
	while ( len-- ) printf( "%02X ", data[ len ]);
}

void print_version( void )
{
	printf( VERSION_STRING );
}

/** \} */
